<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GAME TILE RE-NAMER</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: 'Inter', sans-serif; /* A nice default sans-serif font */
    }
    /* For custom scrollbars if needed, optional */
    ::-webkit-scrollbar {
      width: 8px;
    }
    ::-webkit-scrollbar-track {
      background: #f1f1f1;
    }
    ::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 4px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: #555;
    }
  </style>
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "@google/genai": "https://esm.sh/@google/genai@^1.5.0",
    "jszip": "https://esm.sh/jszip@3.10.1",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.1.1/",
    "react/": "https://aistudiocdn.com/react@^19.1.1/"
  }
}
</script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<link rel="stylesheet" href="/index.css">
</head>
<body class="bg-slate-100 text-slate-800">
  <div id="root"></div>
  <script type="text/babel" data-presets="react,typescript" data-type="module">
    // External imports resolved by the import map
    import React, { useState, useEffect, useCallback } from 'react';
    import ReactDOM from 'react-dom/client';
    import { GoogleGenAI } from "@google/genai";
    import JSZip from 'jszip';

    // ===== From constants.ts =====
    const GEMINI_MODEL_TEXT = 'gemini-2.5-flash';
    const NO_TEXT_DETECTED_MARKER = 'NO_TEXT_DETECTED';
    const MAPPING_COL_GAME_NAME = "Name";
    const MAPPING_COL_IMS_CODE = "IMS Game Code";
    const MAPPING_COL_PROVIDER = "Game Provider";

    // ===== From services/geminiService.ts =====
    const fileToBase64 = (file) => {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => {
          const result = reader.result;
          // Remove "data:image/webp;base64," prefix
          resolve(result.substring(result.indexOf(',') + 1));
        };
        reader.onerror = (error) => reject(error);
      });
    };

    const extractTextFromImageUsingGemini = async (
      apiKey,
      base64ImageData,
      mimeType = 'image/webp'
    ) => {
      if (!apiKey) {
        console.error("Gemini API key is not set.");
        throw new Error("API Key for Gemini is missing.");
      }

      try {
        const ai = new GoogleGenAI({ apiKey });
        const imagePart = {
          inlineData: {
            mimeType: mimeType,
            data: base64ImageData,
          },
        };
        const textPart = {
          text: "Extract all text visible in this image. If no text is clearly visible, respond with 'NO_TEXT_DETECTED'. Focus on game titles or prominent text.",
        };

        const response = await ai.models.generateContent({
          model: GEMINI_MODEL_TEXT,
          contents: { parts: [imagePart, textPart] },
          config: { thinkingConfig: { thinkingBudget: 0 } } // Low latency for faster OCR
        });

        const text = response.text;
        if (text && text.trim() !== "" && !text.includes("NO_TEXT_DETECTED")) {
          return text.trim();
        }
        return null; // No text detected or only marker found
      } catch (error) {
        console.error("Error calling Gemini API:", error);
        if (error instanceof Error && error.message.includes("API key not valid")) {
            throw new Error("Invalid API Key for Gemini. Please check the provided key.");
        }
        throw new Error("Failed to extract text using Gemini API.");
      }
    };

    // ===== From components/Loader.tsx =====
    const Loader = ({ size = 'w-5 h-5', color = 'currentColor' }) => {
      return (
        <svg
          className={`animate-spin ${size} ${color}`}
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
        >
          <circle
            className="opacity-25"
            cx="12"
            cy="12"
            r="10"
            stroke="currentColor"
            strokeWidth="4"
          ></circle>
          <path
            className="opacity-75"
            fill="currentColor"
            d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
          ></path>
        </svg>
      );
    };

    // ===== From components/ImageCard.tsx =====
    const InfoRow = ({ label, value, valueClassName, children }) => (
      <div className="mb-2">
        <span className="text-xs text-slate-400 block">{label}</span>
        {value !== undefined && value !== null && <p className={`text-sm text-slate-200 break-words ${valueClassName || ''}`}>{value}</p>}
        {children}
      </div>
    );

    const ImageCard = ({ imageInfo, onRetry, onDownload, disabled }) => {
      const { id, previewUrl, originalName, status, suggestedName, errorMessage, gameProvider, ocrText, width, height, imageType } = imageInfo;

      let statusColor = 'bg-slate-600';
      let statusText = 'Queued';

      switch (status) {
        case 'api_key_missing':
          statusColor = 'bg-red-700';
          statusText = 'API Key Missing';
          break;
        case 'mapping_parse_error':
          statusColor = 'bg-red-700';
          statusText = 'Mapping Error';
          break;
        case 'ocr_extracting':
          statusColor = 'bg-sky-500 animate-pulse';
          statusText = 'OCR Extracting...';
          break;
        case 'name_matching':
          statusColor = 'bg-sky-500 animate-pulse';
          statusText = 'Matching Name...';
          break;
        case 'processing': // Legacy or general processing
          statusColor = 'bg-sky-500 animate-pulse';
          statusText = 'Processing...';
          break;
        case 'completed':
          statusColor = 'bg-green-500';
          statusText = 'Completed';
          break;
        case 'error':
          statusColor = 'bg-red-500';
          statusText = 'Error';
          break;
      }

      const showOcrText = ocrText && ocrText !== 'OCR_FAILED' && ocrText !== NO_TEXT_DETECTED_MARKER;
      const canRetry = status === 'error' || status === 'api_key_missing' || status === 'mapping_parse_error';

      return (
        <div className={`bg-slate-700/70 rounded-lg shadow-lg overflow-hidden flex flex-col transition-all duration-300 hover:shadow-sky-500/30 ${disabled && !canRetry ? 'opacity-70 cursor-not-allowed' : ''}`}>
          <div className="relative aspect-video bg-slate-800">
            <img src={previewUrl} alt={originalName} className="w-full h-full object-contain" />
            <div className={`absolute top-2 right-2 px-2 py-1 text-xs text-white rounded ${statusColor} z-10`}>
              {statusText}
            </div>
          </div>
          
          <div className="p-4 flex-grow flex flex-col justify-between">
            <div>
              <InfoRow label="Original Name" value={originalName} valueClassName="truncate" />

              {width && height ? (
                <InfoRow 
                  label="Dimensions" 
                  value={`${width}x${height}${imageType && imageType !== 'standard' ? ` (${imageType})` : ''}`}
                  valueClassName="text-xs text-slate-400 capitalize"
                />
              ) : null}

              {(status === 'ocr_extracting' || status === 'name_matching' || status === 'processing') && (
                <div className="flex items-center justify-center my-4 text-sky-300">
                  <Loader /> <span className="ml-2 text-sm">{statusText}</span>
                </div>
              )}

              {showOcrText && (
                 <InfoRow label="OCR Text" value={ocrText} valueClassName="text-slate-300 max-h-16 overflow-y-auto text-xs" />
              )}
              {ocrText === NO_TEXT_DETECTED_MARKER && (
                 <InfoRow label="OCR Text" value="No significant text detected" valueClassName="text-slate-400 text-xs italic" />
              )}


              {status === 'completed' && (
                <>
                  <InfoRow label="New Name" value={suggestedName} valueClassName="font-semibold text-sky-300" />
                  {gameProvider && <InfoRow label="Provider" value={gameProvider} valueClassName="text-slate-300" />}
                </>
              )}

              {errorMessage && (status === 'error' || status === 'api_key_missing' || status === 'mapping_parse_error') && (
                <InfoRow label="Error" valueClassName="text-red-300">
                  <p className="text-sm break-words">{errorMessage}</p>
                </InfoRow>
              )}
            </div>

            <div className="mt-4 pt-4 border-t border-slate-600 flex space-x-2">
              {status === 'completed' && suggestedName && (
                <button
                  onClick={() => onDownload(id)}
                  className="flex-1 px-3 py-2 bg-sky-600 hover:bg-sky-700 text-white text-sm rounded-md transition-colors duration-150 shadow-sm flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed"
                  disabled={disabled}
                  aria-label={`Download ${suggestedName}`}
                >
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 mr-1.5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
                    <path strokeLinecap="round" strokeLinejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                  </svg>
                  Download
                </button>
              )}
              {canRetry && (
                <button
                  onClick={() => onRetry(id)}
                  className="flex-1 px-3 py-2 bg-amber-500 hover:bg-amber-600 text-white text-sm rounded-md transition-colors duration-150 shadow-sm flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed"
                  disabled={disabled}
                  aria-label={`Retry processing for ${originalName}`}
                >
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 mr-1.5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
                    <path strokeLinecap="round" strokeLinejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                  </svg>
                  Retry
                </button>
              )}
               {/* Placeholder for layout consistency if no buttons */}
               {!(status === 'completed' && suggestedName) && !canRetry && (
                 <div className="flex-1 h-9"></div>
               )}
            </div>
          </div>
        </div>
      );
    };

    // ===== From components/FileUpload.tsx =====
    const FileUpload = ({ onFilesSelected, disabled }) => {
      const [isDragging, setIsDragging] = useState(false);

      const handleFileChange = useCallback((event) => {
        if (event.target.files) {
          const webpFiles = Array.from(event.target.files).filter(file => file.type === 'image/webp');
          if (webpFiles.length > 0) {
            onFilesSelected(webpFiles);
          } else if (event.target.files.length > 0) {
            alert("Please select .webp files only.");
          }
        }
        if (event.target) {
            event.target.value = ''; // Reset input to allow re-uploading the same file
        }
      }, [onFilesSelected]);

      const handleDragEnter = useCallback((event) => {
        event.preventDefault();
        event.stopPropagation();
        if (disabled) return;
        setIsDragging(true);
      }, [disabled]);

      const handleDragLeave = useCallback((event) => {
        event.preventDefault();
        event.stopPropagation();
        if (disabled) return;
        if (event.currentTarget.contains(event.relatedTarget)) {
            return;
        }
        setIsDragging(false);
      }, [disabled]);
      
      const handleDragOver = useCallback((event) => {
        event.preventDefault();
        event.stopPropagation();
        if (disabled) return;
      }, [disabled]);

      const handleDrop = useCallback((event) => {
        event.preventDefault();
        event.stopPropagation();
        if (disabled) return;
        setIsDragging(false);
        if (event.dataTransfer.files && event.dataTransfer.files.length > 0) {
          const webpFiles = Array.from(event.dataTransfer.files).filter(file => file.type === 'image/webp');
           if (webpFiles.length > 0) {
            onFilesSelected(webpFiles);
          } else if (event.dataTransfer.files.length > 0) {
            alert("Please drop .webp files only.");
          }
          event.dataTransfer.clearData();
        }
      }, [onFilesSelected, disabled]);


      return (
        <div className="mb-6">
          <label
            htmlFor="file-upload"
            onDragEnter={handleDragEnter}
            onDragLeave={handleDragLeave}
            onDragOver={handleDragOver}
            onDrop={handleDrop}
            className={`
              flex flex-col items-center justify-center w-full h-48 px-4 
              border-2 border-dashed rounded-lg cursor-pointer transition-colors duration-200 ease-in-out
              group
              ${disabled ? 'bg-slate-700/30 border-slate-600/50 cursor-not-allowed' : 
                         isDragging ? 'bg-sky-700/30 border-sky-500' : 'bg-slate-700/80 hover:bg-slate-600/80 border-slate-500 hover:border-sky-400'}
            `}
            aria-disabled={disabled}
          >
            <svg xmlns="http://www.w3.org/2000/svg" className={`w-12 h-12 mb-3 ${disabled ? 'text-slate-500' : 'text-slate-400 group-hover:text-sky-300 transition-colors'}`} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="1.5">
              <path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5" />
            </svg>
            <p className={`mb-1 text-sm ${disabled ? 'text-slate-500' : 'text-slate-300'}`}>
              <span className="font-semibold">Click to upload</span> or drag and drop
            </p>
            <p className={`text-xs ${disabled ? 'text-slate-600' : 'text-slate-400'}`}>
              .WEBP files only
            </p>
             <p className={`mt-1 text-xs ${disabled ? 'text-slate-600' : 'text-slate-500'}`}>
              (Processing starts after you provide mappings and click "Start Processing All")
            </p>
            <input
              id="file-upload"
              type="file"
              className="hidden"
              accept="image/webp"
              multiple
              onChange={handleFileChange}
              disabled={disabled}
            />
          </label>
          {disabled && (
            <p className="text-xs text-amber-400 mt-2 text-center">File upload is disabled. Ensure an API key is set and no processing is active.</p>
          )}
        </div>
      );
    };

    // ===== From App.tsx =====
    const App = () => {
      const [processedImages, setProcessedImages] = useState([]);
      const [isCurrentlyProcessingImage, setIsCurrentlyProcessingImage] = useState(false);
      const [startProcessingFlag, setStartProcessingFlag] = useState(false);
      const [isZipping, setIsZipping] = useState(false);
      
      const [apiKey, setApiKey] = useState(null);
      const [apiKeyInput, setApiKeyInput] = useState('');

      const [pastedCustomMappings, setPastedCustomMappings] = useState('');
      const [manualFilenameMappings, setManualFilenameMappings] = useState([]);
      const [mappingParseMessage, setMappingParseMessage] = useState(null);
      const [unusedMappingsMessage, setUnusedMappingsMessage] = useState(null);
      const [startAttemptErrorMessage, setStartAttemptErrorMessage] = useState(null);

      const normalizeText = (text) => {
        if (!text) return "";
        return text.toLowerCase().replace(/[^a-z0-9]/gi, '');
      };

      const getImageMetadata = (file) => {
        return new Promise((resolve, reject) => {
          const img = new Image();
          const objectUrl = URL.createObjectURL(file);
          img.onload = () => {
            const { width, height } = img;
            let imageType = 'standard';
            if (width === 500 && height === 693) {
              imageType = 'portrait';
            } else if (width === 500 && height === 333) {
              imageType = 'landscape';
            }
            resolve({ width, height, imageType });
            URL.revokeObjectURL(objectUrl);
          };
          img.onerror = (err) => {
              reject(err);
              URL.revokeObjectURL(objectUrl);
          };
          img.src = objectUrl;
        });
      };

      const sanitizeFilename = (name, fallbackName = 'renamed_image', maxLength = 50) => {
        let saneName = name.replace(/\.webp$/i, '');
        saneName = saneName.replace(/[^\w.-]/gi, '_');
        saneName = saneName.replace(/\s+/g, '_');
        if (saneName.length > maxLength) {
          saneName = saneName.substring(0, maxLength);
        }
        saneName = saneName.replace(/[_.-]+$/, '').replace(/^[_.-]+/, '');
        return saneName || fallbackName;
      };

      const parseCustomMappings = useCallback((mappingsString) => {
        if (!mappingsString.trim()) {
          setMappingParseMessage("Mapping data is empty. Paste your tab-separated table.");
          return [];
        }
        const lines = mappingsString.trim().split('\n');
        if (lines.length === 0) {
          setMappingParseMessage("No lines found in mapping data.");
          return [];
        }

        const headerLine = lines[0].toLowerCase().split('\t').map(h => h.trim());
        const gameNameIndex = headerLine.indexOf(MAPPING_COL_GAME_NAME.toLowerCase());
        const imsCodeIndex = headerLine.indexOf(MAPPING_COL_IMS_CODE.toLowerCase());
        const providerIndex = headerLine.indexOf(MAPPING_COL_PROVIDER.toLowerCase());

        if (gameNameIndex === -1 || imsCodeIndex === -1) {
          setMappingParseMessage(`Error: Required columns missing. Ensure '${MAPPING_COL_GAME_NAME}' and '${MAPPING_COL_IMS_CODE}' headers are present. Data should be tab-separated.`);
          return [];
        }

        const newMappings = [];
        for (let i = 1; i < lines.length; i++) {
          const cells = lines[i].split('\t').map(cell => cell.trim());
          if (cells.length > Math.max(gameNameIndex, imsCodeIndex)) {
            const gameName = cells[gameNameIndex];
            const imsGameCode = cells[imsCodeIndex];
            const provider = providerIndex !== -1 && cells.length > providerIndex ? cells[providerIndex] : undefined;

            if (gameName && imsGameCode) {
              newMappings.push({ gameName, imsGameCode, provider: provider || undefined });
            }
          }
        }
        
        if (newMappings.length === 0 && lines.length > 1) {
             setMappingParseMessage("Mappings parsed, but no valid entries found after the header row. Check data values and ensure they are tab-separated under the correct headers.");
        } else if (newMappings.length > 0) {
            setMappingParseMessage(`Successfully parsed ${newMappings.length} mapping entries.`);
        } else {
            setMappingParseMessage("No mapping entries found. Ensure data is present after the header row or check header names.");
        }
        return newMappings;
      }, []);


      const findMatchingGame = (
        ocrText,
        originalFilename,
        mappings
      ) => {
        const filenameGamePart = (originalFilename.substring(0, originalFilename.lastIndexOf('.')) || originalFilename)
                                   .replace(/^[0-9]+x[0-9]+-/, '');
        
        const normalizedOcr = normalizeText(ocrText ?? "");
        const normalizedFilename = normalizeText(filenameGamePart);
      
        let bestMatch = null;
        let highestScore = 0;

        for (const mapping of mappings) {
          const normalizedMappingGameName = normalizeText(mapping.gameName);
          if (!normalizedMappingGameName) continue;

          let currentScore = 0;
          
          if (normalizedOcr) {
            if (normalizedMappingGameName.includes(normalizedOcr)) {
              currentScore = Math.max(currentScore, 20 + normalizedOcr.length);
            }
            if (normalizedOcr.includes(normalizedMappingGameName)) {
              currentScore = Math.max(currentScore, 20 + normalizedMappingGameName.length);
            }
          }

          if (normalizedFilename) {
            if (normalizedMappingGameName.includes(normalizedFilename)) {
              currentScore = Math.max(currentScore, 10 + normalizedFilename.length);
            }
            if (normalizedFilename.includes(normalizedMappingGameName)) {
              currentScore = Math.max(currentScore, 10 + normalizedMappingGameName.length);
            }
          }
          
          if (currentScore > highestScore) {
            highestScore = currentScore;
            bestMatch = mapping;
          }
        }
        return bestMatch;
      };

      const processSingleImage = useCallback(async (imageToProcess, currentMappings) => {
        if (!apiKey) {
          setProcessedImages(prev => prev.map(img => img.id === imageToProcess.id ? { ...img, status: 'api_key_missing', errorMessage: "API Key is missing. OCR skipped." } : img));
          return;
        }
         if (currentMappings.length === 0) {
          setProcessedImages(prev => prev.map(img => img.id === imageToProcess.id ? { ...img, status: 'mapping_parse_error', errorMessage: "No valid mappings loaded. Cannot process." } : img));
          return;
        }

        setProcessedImages(prev => prev.map(img => img.id === imageToProcess.id ? { ...img, status: 'ocr_extracting' } : img));
        
        let ocrText = null;
        try {
          const base64Data = await fileToBase64(imageToProcess.file);
          ocrText = await extractTextFromImageUsingGemini(apiKey, base64Data, imageToProcess.file.type);
          setProcessedImages(prev => prev.map(img => img.id === imageToProcess.id ? { ...img, ocrText: ocrText || NO_TEXT_DETECTED_MARKER, status: 'name_matching' } : img));
        } catch (error) {
          console.error("Error during OCR extraction:", error);
          setProcessedImages(prev => prev.map(img => img.id === imageToProcess.id ? {
            ...img,
            status: 'error',
            errorMessage: error.message || 'Failed OCR extraction.',
            ocrText: 'OCR_FAILED'
          } : img));
          return; 
        }

        try {
          const matchedMapping = findMatchingGame(ocrText, imageToProcess.originalName, currentMappings);

          if (matchedMapping) {
            const suggestedName = `${sanitizeFilename(matchedMapping.imsGameCode, matchedMapping.imsGameCode)}.webp`;
            setProcessedImages(prev => prev.map(img => img.id === imageToProcess.id ? {
              ...img,
              status: 'completed',
              suggestedName: suggestedName,
              gameProvider: matchedMapping.provider,
              errorMessage: undefined,
            } : img));
          } else {
            setProcessedImages(prev => prev.map(img => img.id === imageToProcess.id ? {
              ...img,
              status: 'error',
              errorMessage: 'Game not found in mappings.',
            } : img));
          }
        } catch (error) {
          console.error("Error during name matching/processing image:", error);
          setProcessedImages(prev => prev.map(img => img.id === imageToProcess.id ? {
            ...img,
            status: 'error',
            errorMessage: error.message || 'Failed to process and match name.',
          } : img));
        }
      }, [apiKey, findMatchingGame, sanitizeFilename]); 

      useEffect(() => {
        if (isCurrentlyProcessingImage || !startProcessingFlag || isZipping) return;

        const nextImageToProcess = processedImages.find(img => img.status === 'queued');
        if (nextImageToProcess) {
          setIsCurrentlyProcessingImage(true);
          processSingleImage(nextImageToProcess, manualFilenameMappings).finally(() => {
            setIsCurrentlyProcessingImage(false);
          });
        } else if (startProcessingFlag && processedImages.length > 0) {
          setStartProcessingFlag(false);
        }
      }, [processedImages, isCurrentlyProcessingImage, processSingleImage, startProcessingFlag, manualFilenameMappings, isZipping]);


      const handleFilesSelected = async (files) => {
        setStartAttemptErrorMessage(null);
        setUnusedMappingsMessage(null);

        const newImagesPromises = files.map(async (file, index) => {
          const previewUrl = URL.createObjectURL(file);
          try {
            const { width, height, imageType } = await getImageMetadata(file);
            return {
              id: `${Date.now()}-${index}-${file.name}`,
              file,
              originalName: file.name,
              previewUrl,
              status: apiKey ? 'queued' : 'api_key_missing',
              errorMessage: apiKey ? undefined : "API Key is missing.",
              width,
              height,
              imageType,
            };
          } catch (error) {
            console.error(`Failed to read metadata for ${file.name}:`, error);
            return {
              id: `${Date.now()}-${index}-${file.name}`,
              file,
              originalName: file.name,
              previewUrl,
              status: 'error',
              errorMessage: 'Could not read image dimensions.',
              width: undefined,
              height: undefined,
              imageType: 'standard',
            };
          }
        });

        const newImages = await Promise.all(newImagesPromises);
        setProcessedImages(prev => [...prev, ...newImages]);
      };

      const handleStartAllProcessing = () => {
        setStartAttemptErrorMessage(null);
        setUnusedMappingsMessage(null);
        
        const currentParsedMappings = parseCustomMappings(pastedCustomMappings);
        setManualFilenameMappings(currentParsedMappings);

        if (currentParsedMappings.length > 0 && processedImages.length > 0) {
          const allImageOriginalNamesNormalized = processedImages.map(img => normalizeText(img.originalName.substring(0, img.originalName.lastIndexOf('.')) || img.originalName));
          const trulyUnusedMappingNames = [];

          currentParsedMappings.forEach(mapping => {
            const normalizedMappingGameName = normalizeText(mapping.gameName);
            if (!normalizedMappingGameName) return;

            const isPotentiallyUsed = allImageOriginalNamesNormalized.some(imgName => 
              imgName.includes(normalizedMappingGameName)
            );

            if (!isPotentiallyUsed) {
              trulyUnusedMappingNames.push(mapping.gameName);
            }
          });

          if (trulyUnusedMappingNames.length > 0) {
            const limit = 3;
            const namesToShow = trulyUnusedMappingNames.slice(0, limit).join('", "');
            const moreCount = trulyUnusedMappingNames.length - limit;
            const moreText = moreCount > 0 ? ` (and ${moreCount} more)` : '';
            setUnusedMappingsMessage(`Note: No uploaded images seem to directly relate to mapping entries for: "${namesToShow}"${moreText}. These mappings might not be used if OCR also doesn't find a match.`);
          }
        }

        if (!apiKey) {
          setStartAttemptErrorMessage("Cannot start processing: API Key is missing. OCR functionality requires it.");
          return;
        }
        
        if (pastedCustomMappings.trim() === "") {
            setStartAttemptErrorMessage("Cannot start processing: Mapping data is empty. Please paste your game mappings.");
            return;
        }

        if (currentParsedMappings.length === 0) {
            const baseMessage = "Cannot start processing: No valid mapping entries found. ";
            const specificError = (mappingParseMessage && mappingParseMessage.toLowerCase().startsWith("error:")) ? 
                                  mappingParseMessage : 
                                  "Please check mapping data format, ensure headers ('Name', 'IMS Game Code') are correct and data exists under them.";
            setStartAttemptErrorMessage(baseMessage + specificError);
            return;
        }

        const imagesToProcess = processedImages.filter(img => 
            ['queued', 'error', 'api_key_missing', 'mapping_parse_error'].includes(img.status)
        );

        if (imagesToProcess.length === 0) {
          setStartAttemptErrorMessage(processedImages.length === 0 ? 
              "Cannot start processing: No images have been uploaded." : 
              "Cannot start processing: No images are currently pending or in an error state to reprocess."
          );
          return;
        }
        
        setProcessedImages(prev => prev.map(img =>
          (imagesToProcess.some(procImg => procImg.id === img.id))
            ? { ...img, status: 'queued', errorMessage: undefined, gameProvider: undefined, suggestedName: undefined, ocrText: undefined }
            : img
        ));
        setStartProcessingFlag(true);
      };
      
      const handleRetry = (id) => {
        setProcessedImages(prev => prev.map(img => img.id === id ? { ...img, status: 'queued', errorMessage: undefined, gameProvider: undefined, suggestedName: undefined, ocrText: undefined } : img));
        if (!startProcessingFlag && !isCurrentlyProcessingImage) {
            setStartProcessingFlag(true); 
        }
      };

      const handleDownload = (id) => {
        const imageInfo = processedImages.find(img => img.id === id);
        if (imageInfo && imageInfo.file && imageInfo.suggestedName) {
          const link = document.createElement('a');
          link.href = imageInfo.previewUrl;
          link.download = imageInfo.suggestedName;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }
      };
      
      const handleClearAll = () => {
        processedImages.forEach(img => URL.revokeObjectURL(img.previewUrl));
        setProcessedImages([]);
        setStartProcessingFlag(false);
        setIsCurrentlyProcessingImage(false);
        setIsZipping(false);
        setMappingParseMessage(null);
        setUnusedMappingsMessage(null);
        setStartAttemptErrorMessage(null);
      };

      const createAndDownloadZip = useCallback(async () => {
        setIsZipping(true);
        setStartAttemptErrorMessage(null);
        const zip = new JSZip();
        const completedImages = processedImages.filter(img => img.status === 'completed' && img.suggestedName);
        const unprocessedImages = processedImages.filter(img => img.status !== 'completed');

        if (completedImages.length === 0 && unprocessedImages.length === 0) {
          setStartAttemptErrorMessage("Download failed: No images are available to include in the ZIP.");
          setIsZipping(false);
          return;
        }

        completedImages.forEach(imageInfo => {
          if (imageInfo.file && imageInfo.suggestedName) {
            let filePathInZip = imageInfo.suggestedName;
            if (imageInfo.gameProvider && imageInfo.gameProvider.trim() !== "") {
              const sanitizedProvider = sanitizeFilename(imageInfo.gameProvider, 'default_provider');
              
              let subfolder = '';
              if (imageInfo.imageType === 'portrait') {
                subfolder = 'portrait/';
              } else if (imageInfo.imageType === 'landscape') {
                subfolder = 'landscape/';
              }
              
              filePathInZip = `${sanitizedProvider}/${subfolder}${imageInfo.suggestedName}`;
            }
            zip.file(filePathInZip, imageInfo.file);
          }
        });
        
        if (unprocessedImages.length > 0) {
            const unprocessedFolder = zip.folder("unprocessed");
            unprocessedImages.forEach(imageInfo => {
                if (imageInfo.file) {
                    unprocessedFolder.file(imageInfo.originalName, imageInfo.file);
                }
            });
        }

        try {
          const zipBlob = await zip.generateAsync({ type: "blob" });
          const link = document.createElement('a');
          link.href = URL.createObjectURL(zipBlob);
          link.download = `renamed_images_${Date.now()}.zip`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(link.href);
        } catch (error) {
          console.error("Error creating ZIP file:", error);
          setStartAttemptErrorMessage("An unexpected error occurred while creating the ZIP file.");
        } finally {
          setIsZipping(false);
        }
      }, [processedImages, sanitizeFilename]);

      const handleDownloadZip = () => {
        createAndDownloadZip();
      }
                               
      const canStartProcessing = (apiKey != null) && 
                               (processedImages.some(img => ['queued', 'error', 'api_key_missing', 'mapping_parse_error'].includes(img.status))) && 
                               !isCurrentlyProcessingImage && !startProcessingFlag && !isZipping &&
                               (pastedCustomMappings.trim() !== ""); 
                               
      const globalDisable = isCurrentlyProcessingImage || startProcessingFlag || isZipping || !apiKey;
      const processingQueueCount = processedImages.filter(img => ['queued', 'ocr_extracting', 'name_matching', 'processing'].includes(img.status)).length;
      const completedImagesCount = processedImages.filter(img => img.status === 'completed').length;
      const canDownloadZip = processedImages.length > 0 && !isZipping && !startProcessingFlag && !isCurrentlyProcessingImage;


      return (
        <div className="min-h-screen bg-gradient-to-br from-slate-900 to-slate-700 text-slate-100 p-4 sm:p-8 flex flex-col items-center">
          <header className="w-full max-w-4xl mb-8 text-center">
            <img src="https://digibeat.com/wp-content/uploads/2022/06/logo-white-300x80.png" alt="Digibeat Logo" className="mx-auto mb-4 h-12" />
            <h1 className="text-4xl sm:text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-sky-400 to-cyan-300">
              GAME TILE RE-NAMER
            </h1>
            <p className="mt-2 text-slate-300 text-sm sm:text-base">
              Rename .webp images using OCR and filename analysis against your custom game mappings. Output to an organized ZIP.
            </p>
          </header>

          <div className="w-full max-w-4xl p-6 mb-6 bg-slate-800/70 shadow-lg rounded-xl backdrop-blur-md border border-slate-700">
            <h2 className="text-lg font-semibold text-slate-200 mb-2 flex items-center">
              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 text-sky-400" viewBox="0 0 20 20" fill="currentColor">
                <path fillRule="evenodd" d="M18 8a6 6 0 01-7.743 5.743L10 14l-1 1-1 1H6v2H2v-4l4.257-4.257A6 6 0 1118 8zm-6-4a1 1 0 100 2 1 1 0 000-2z" clipRule="evenodd" />
              </svg>
              API Key Configuration
            </h2>
            <p className="text-xs text-slate-400 mb-3">
              A Google Gemini API key is required for OCR. You can get one from <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer" className="text-sky-400 hover:underline">Google AI Studio</a>.
            </p>
            <div className="flex items-center gap-2">
              <input
                type="password"
                value={apiKeyInput}
                onChange={(e) => setApiKeyInput(e.target.value)}
                onKeyDown={(e) => { if (e.key === 'Enter') { setApiKey(apiKeyInput.trim()); } }}
                placeholder="Enter your Gemini API Key here..."
                className="flex-grow p-2 bg-slate-900/70 border border-slate-600 rounded-md focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition-colors text-slate-300 text-sm placeholder-slate-500"
                aria-label="Gemini API Key input"
              />
              <button
                onClick={() => {
                  const trimmedKey = apiKeyInput.trim();
                  setApiKey(trimmedKey);
                  if (trimmedKey) {
                    setProcessedImages(prev => prev.map(img => img.status === 'api_key_missing' ? { ...img, status: 'queued', errorMessage: undefined } : img));
                  }
                }}
                className="px-4 py-2 bg-sky-600 hover:bg-sky-500 text-white font-bold rounded-lg shadow-md transition-all duration-200 ease-in-out disabled:bg-slate-600"
                disabled={!apiKeyInput.trim()}
              >
                Set Key
              </button>
            </div>
            {apiKey ? (
              <p className="mt-2 text-sm text-green-400">
                API Key is set. Ready for processing.
              </p>
            ) : (
              <p className="mt-2 text-sm text-red-400">
                API Key is not set. Please enter your key to enable OCR functionality.
              </p>
            )}
          </div>

          <main className="w-full max-w-4xl bg-slate-800/70 shadow-2xl rounded-xl p-6 sm:p-8 backdrop-blur-md border border-slate-700">
            <FileUpload onFilesSelected={handleFilesSelected} disabled={globalDisable || !apiKey} />
            
            <div className="my-6 p-4 bg-slate-700/50 rounded-lg">
              <h3 className="text-lg font-semibold text-slate-200 mb-2">Custom Game Mappings (Tab-Separated)</h3>
              <p className="text-xs text-slate-400 mb-1">Paste table data (e.g., from a spreadsheet). Must include headers: "{MAPPING_COL_GAME_NAME}", "{MAPPING_COL_IMS_CODE}". Optional: "{MAPPING_COL_PROVIDER}". Other columns will be ignored.</p>
              <p className="text-xs text-slate-400 mb-2">Example (ensure values are separated by tabs, not spaces):</p>
              <pre className="text-xs text-slate-400 bg-slate-900 p-2 rounded mb-2 overflow-x-auto">
                {`${MAPPING_COL_GAME_NAME}\t${MAPPING_COL_PROVIDER}\tSome Other Column\t${MAPPING_COL_IMS_CODE}\tYet Another Column\nKing's Mystery\tPlaytech\tData To Ignore\tggas_kmsterya1_pop\tMore Ignored Data\nThree Fold the Gold\tGames Global\t2025-01-01\t123456vds_mcg\tActive`}
              </pre>
              <textarea
                className="w-full h-32 p-2 bg-slate-900/70 border border-slate-600 rounded-md focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition-colors text-slate-300 text-sm disabled:opacity-50"
                placeholder="Paste your tab-separated data here..."
                value={pastedCustomMappings}
                onChange={(e) => setPastedCustomMappings(e.target.value)}
                disabled={globalDisable}
                aria-label="Custom game mappings input"
              />
              {mappingParseMessage && (
                <p className={`mt-2 text-xs ${mappingParseMessage.toLowerCase().startsWith('error:') ? 'text-red-400' : 'text-green-400'}`}>
                  {mappingParseMessage}
                </p>
              )}
            </div>

            <div className="flex flex-wrap gap-4 items-center justify-between mt-6 border-t border-slate-700 pt-6">
              <div className="flex gap-4">
                <button
                  onClick={handleStartAllProcessing}
                  disabled={!canStartProcessing}
                  className="px-6 py-2 bg-sky-600 hover:bg-sky-500 text-white font-bold rounded-lg shadow-md transition-all duration-200 ease-in-out disabled:bg-slate-600 disabled:text-slate-400 disabled:cursor-not-allowed disabled:shadow-none transform hover:scale-105 disabled:scale-100 flex items-center"
                  aria-label="Start processing all queued images"
                >
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-8.707l-3-3a1 1 0 00-1.414 0l-3 3a1 1 0 001.414 1.414L9 9.414V13a1 1 0 102 0V9.414l1.293 1.293a1 1 0 001.414-1.414z" clipRule="evenodd" />
                  </svg>
                  Start Processing All
                </button>
                <button
                  onClick={handleClearAll}
                  disabled={processedImages.length === 0 || isCurrentlyProcessingImage || startProcessingFlag || isZipping}
                  className="px-4 py-2 bg-slate-600 hover:bg-slate-500 text-slate-200 font-bold rounded-lg shadow-md transition-all duration-200 ease-in-out disabled:bg-slate-700 disabled:text-slate-500 disabled:cursor-not-allowed disabled:shadow-none"
                  aria-label="Clear all uploaded images and data"
                >
                  Clear All
                </button>
              </div>
              <button
                onClick={handleDownloadZip}
                disabled={!canDownloadZip}
                className="px-6 py-2 bg-green-600 hover:bg-green-500 text-white font-bold rounded-lg shadow-md transition-all duration-200 ease-in-out disabled:bg-slate-600 disabled:text-slate-400 disabled:cursor-not-allowed disabled:shadow-none transform hover:scale-105 disabled:scale-100 flex items-center"
                aria-label="Download all completed images as a ZIP"
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                  <path strokeLinecap="round" strokeLinejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                </svg>
                Download ZIP ({completedImagesCount})
              </button>
            </div>
            
            {startAttemptErrorMessage && (
                <div className="mt-4 p-3 bg-red-500/30 border border-red-700 text-red-200 rounded-md text-center text-sm">
                    <p>{startAttemptErrorMessage}</p>
                </div>
            )}
            {unusedMappingsMessage && !startAttemptErrorMessage && (
                <div className="mt-4 p-3 bg-amber-500/20 border border-amber-700 text-amber-200 rounded-md text-sm">
                    <p>{unusedMappingsMessage}</p>
                </div>
            )}


            {processingQueueCount > 0 && (
              <div className="mt-6 text-center text-sky-300">
                 <p>{processingQueueCount} image(s) in processing queue...</p>
              </div>
            )}
          </main>

          {processedImages.length > 0 && (
            <section className="w-full max-w-4xl mt-8">
              <h2 className="text-2xl font-semibold mb-4 text-slate-200">Processing Results</h2>
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                {processedImages.map(imageInfo => (
                  <ImageCard 
                    key={imageInfo.id} 
                    imageInfo={imageInfo} 
                    onRetry={handleRetry} 
                    onDownload={handleDownload}
                    disabled={isCurrentlyProcessingImage || startProcessingFlag || isZipping}
                  />
                ))}
              </div>
            </section>
          )}

          <footer className="w-full max-w-4xl mt-auto pt-8 pb-4 text-center text-slate-500 text-sm">
            <p>Â© 2025 Created by Bob Fox. Built with React & Tailwind CSS.</p>
          </footer>
        </div>
      );
    };

    // ===== From index.tsx =====
    const rootElement = document.getElementById('root');
    if (!rootElement) {
      throw new Error("Could not find root element to mount to");
    }

    const root = ReactDOM.createRoot(rootElement);
    root.render(
      <React.StrictMode>
        <App />
      </React.StrictMode>
    );
  </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>